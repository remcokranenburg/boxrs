extern crate boxrs;
#[macro_use]
extern crate glium;

use std::default::Default;
use std::env;
use std::cell::RefCell;
use std::fs::File;
use std::io::Read;
use std::path::Path;

use boxrs::css::Color;
use boxrs::css::Sheet;
use boxrs::dom::Node;
use boxrs::layout::Dimensions;
use boxrs::layout::LayoutBox;
use boxrs::layout::Rect;
use boxrs::painting::DisplayCommand;
use boxrs::style::StyledNode;
use glium::glutin;
use glium::index::{NoIndices, PrimitiveType};
use glium::{Display, Frame, Program, Surface, VertexBuffer};

#[derive(Copy, Clone)]
struct Vertex {
    position: [f32; 2],
}

implement_vertex!(Vertex, position);

fn draw_color_rectangle(
    target: &mut Frame,
    square_buffer: &VertexBuffer<Vertex>,
    program: &Program,
    color: &Color,
    rect: &Rect,
    layer: f32,
) {
    let indices = NoIndices(PrimitiveType::TriangleStrip);

    let uniforms = uniform! {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        layer: layer,
        in_color: [color.r as f32, color.g as f32, color.b as f32, color.a as f32]
    };

    target
        .draw(
            square_buffer,
            indices,
            program,
            &uniforms,
            &Default::default(),
        )
        .unwrap();
}

fn read_source<P: AsRef<Path>>(filename: P) -> String {
    let mut s = String::new();
    File::open(filename)
        .unwrap()
        .read_to_string(&mut s)
        .unwrap();
    s
}

fn extract_stylesheet(document: &Node, base: &Path) -> Sheet {
    // TODO: replace with:
    // let css_filename = match root_node.select("html > head > link[rel=stylesheet][href]") {
    //   Some(node) => Some(node.get_attribute("href")),
    //   None => None,
    // }

    // TODO: of course, really replace this with something that keeps track of all sheets

    let mut css_filename = None;

    if let Some(Node::Element { attrs, .. }) = document
            .get_elements_by_tag_name("link")
            .first() {
        if attrs.contains(&("rel".to_owned(), "stylesheet".to_owned())) {
            for attr in attrs {
                if attr.0 == "href" {
                    css_filename = Some(base.join(attr.1.clone()));
                }
            }
        }
    }

    println!("Opening CSS file {}", css_filename.as_ref().unwrap().display());

    let css = read_source(&css_filename.unwrap());

    boxrs::parse_css(&css)
}

struct Browser<'a> {
    document: Node,
    stylesheet: Sheet,
    style_root: StyledNode<'a>,
    viewport: Dimensions,
    layout_root: LayoutBox<'a>,
}

impl<'a> Browser<'a> {
    pub fn open(filename: &str) -> Browser {
        let html_source = read_source(filename);
        let base = Path::new(filename).parent().unwrap();
        Browser::from_html(&html_source, &base)
    }

    pub fn from_html(source: &str, base: &Path) -> Browser<'a> {
        let document = boxrs::parse_html(source);
        let stylesheet = extract_stylesheet(&document, base);
        let style_root = boxrs::build_style_tree(&document, &stylesheet);

        let mut viewport: Dimensions = Default::default();
        viewport.content.width = 800.0;
        viewport.content.height = 600.0;

        let layout_root = boxrs::build_layout_tree(&style_root, viewport);

        Browser {
            document: document,
            stylesheet: stylesheet,
            style_root: style_root,
            viewport: viewport,
            layout_root: layout_root,
        }
    }

    pub fn get_title(&self) -> String {
        match self.document.get_elements_by_tag_name("title").first() {
            Some(node) => node.get_text_content(),
            None => "Untitled".to_owned(),
        }
    }

    pub fn set_dimensions(&mut self, width: f32, height: f32) -> bool {
        if width != self.viewport.content.width || height != self.viewport.content.height {
            self.viewport.content.width = width;
            self.viewport.content.height = height;
            self.layout_root = boxrs::build_layout_tree(&self.style_root, self.viewport);
            return true;
        }

        false
    }

    pub fn get_layout_root(&self) -> LayoutBox {
        self.layout_root
    }
}

fn main() {
    let mut args = env::args().skip(1);
    let html_filename = args.next().expect("HTML file provided as first argument");
    let mut browser = Browser::open(&html_filename);
    let title = browser.get_title();

    // open a window with opengl support
    let event_loop = glutin::event_loop::EventLoop::new();
    let wb = glutin::window::WindowBuilder::new().with_title(format!("{title} - html2gl"));
    let cb = glutin::ContextBuilder::new().with_depth_buffer(24);
    let display = Display::new(wb, cb, &event_loop).unwrap();

    // set up drawing

    let square_shape = vec![
        Vertex {
            position: [0.0, 0.0],
        },
        Vertex {
            position: [1.0, 0.0],
        },
        Vertex {
            position: [0.0, 1.0],
        },
        Vertex {
            position: [1.0, 1.0],
        },
    ];
    let square_buffer = VertexBuffer::new(&display, &square_shape).unwrap();

    let vertex_shader_src = r#"
        #version 140

        in vec2 position;

        uniform float x;
        uniform float y;
        uniform float width;
        uniform float height;
        uniform float layer;

        void main() {
            gl_Position = vec4(
                (x + position.x * width) / 800.0 * 2.0 - 1.0,
                (y + position.y * height) / 600.0 * -2.0 + 1.0,
                layer,
                1.0
            );
        }
    "#;

    let fragment_shader_src = r#"
        #version 140

        out vec4 color;

        uniform vec4 in_color;

        vec4 normalize(vec4 c) {
            return c / 255;
        }

        vec3 to_gamma_curve(vec3 c)
        {
            return pow(c, vec3(2.2));
        }

        void main() {
            vec4 normalized = normalize(in_color);
            color = vec4(to_gamma_curve(normalized.rgb), normalized.a);
        }
    "#;

    let program =
        Program::from_source(&display, vertex_shader_src, fragment_shader_src, None).unwrap();

    event_loop.run(move |ev, _, control_flow| {
        control_flow.set_poll();

        let mut redraw = false;

        let mut target = display.draw();
        let (width, height) = target.get_dimensions();

        let is_relayout = browser.set_dimensions(width as f32, height as f32);
        let layout_root = browser.get_layout_root();

        target.clear_color_and_depth((1.0, 1.0, 1.0, 1.0), 1.0);
        let display_list = boxrs::build_display_list(&layout_root);

        let mut layer = 0.0;

        for item in &display_list {
            match item {
                DisplayCommand::SolidColor(color, rect) => {
                    draw_color_rectangle(&mut target, &square_buffer, &program, color, rect, layer);
                }
            }

            layer += 0.001;
        }

        target.finish().unwrap();

        if let glutin::event::Event::WindowEvent { event, .. } = ev {
            if event == glutin::event::WindowEvent::CloseRequested {
                control_flow.set_exit();
            }
        }
    });
}
